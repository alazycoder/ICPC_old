/*
性质： 
1.	一个二分图中的最大匹配数等于这个图中的最小点覆盖数
匹配：给定一个二分图G，M为G边集的一个子集，如果M满足当中的任意两条边都不依附于同一个顶点，则称M是一个匹配。
最大匹配：所含匹配边数最多的匹配
点覆盖：对于图G=(V,E)中的一个点覆盖是一个集合S⊆V使得每一条边至少有一个端点在S中
假如选了一个点就相当于覆盖了以它为端点的所有边，你需要选择最少的点来覆盖所有的边

2 . 二分图的最小路径覆盖数=二分图中的节点数-相应二分图中的最大匹配数.（有向无环图）
其中最大匹配数的求法是把P中的每个顶点pi分成两个顶点pi'与pi''，如果在p中存在一条pi到pj的边，那么在二分图P'中就有一条连接pi'与pj''的无向边；这里pi' 就是p中pi的出边，pj''就是p中pj 的一条入边
（1）一个单独的顶点是一条路径；
（2）如果存在一路径p1,p2,......pk，其中p1 为起点，pk为终点，那么在覆盖图中，顶p1,p2,......pk不再与其它顶点之间存在有向边．

对于公式：最小路径覆盖=|P|－最大匹配数；可以这么来理解；
如果匹配数为零，那么P中不存在有向边，于是显然有：
最小路径覆盖=|P|－最大匹配数=|P|－0=|P|；即P的最小路径覆盖数为|P|；
如果在P'中增加一条匹配边pi'－－>pj''，那么在图P的路径覆盖中就存在一条由pi连接pj的边，也就是说pi与pj 在一条路径上，于是路径覆盖数就可以减少一个；
如此继续增加匹配边，每增加一条，路径覆盖数就减少一条；直到匹配边不能 继续增加时，路径覆盖数也不能再减少了，此时就有了前面的公式；但是这里只 是说明了每条匹配边对应于路径覆盖中的一条路径上的一条连接两个点之间的有向边；下面来说明一个路径覆盖中的每条连接两个顶点之间的有向边对应于一条匹配 边；
与前面类似，对于路径覆盖中的每条连接两个顶点之间的每条有向边 pi--->pj，我们可以在匹配图中对应做一条连接pi'与pj''的边， 显然这样做出来图的是一个匹配图（这一点用反证法很容易证明，如果得到的图不是一个匹配图，那么这个图中必定存在这样两条边 pi'---pj'' 及 pi' ----pk''，（j!=k），那么在路径覆盖图中就存在了两条边pi-->pj, pi--->pk ，那边从pi出发的路径就不止一条了，这与路径覆盖图是矛盾的；还有另外一种情况就是存在pi'---pj'',pk'---pj''，这种情况也类似可 证）；
至此，就说明了匹配边与路径覆盖图中连接两顶点之间边的一一对应关系，那么也就说明了前面的公式成立！

3．二分图最大独立集=顶点数-二分图最大匹配
独立集：图中任意两个顶点都不相连的顶点集合。

*/

vector<int> G[1005];
int used[1005],match[1005];
//通过DFS找增广路
bool dfs(int v)
{
    used[v]=1;
    for(int i=0;i<G[v].size();i++)
    {
        int u=G[v][i],w=match[u];
        if(w==-1||(!used[w]&&dfs(w)))
        {
            match[u]=v;
            match[v]=u;
            return true ;
        }
    }
    return false ;
}

int bipartite_matching()
{
    int res=0;
    memset(match,-1,sizeof(match));
    for(int v=0;v<V;v++) //V是节点总数
    {
        if(match[v]==-1)
        {
            memset(used,0,sizeof(used));
            if(dfs(v))
                res++;
        }
    }
    return res ;
}
